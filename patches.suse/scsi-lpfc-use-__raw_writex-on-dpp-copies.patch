From: James Smart <jsmart2021@gmail.com>
Date: Mon, 5 Mar 2018 10:29:03 -0800
Subject: [PATCH] scsi: lpfc: use __raw_writeX on DPP copies
Patch-mainline: v4.17-rc1
Git-commit: 4c06619fc4da5b7aae76f1dde25bfea3246f2591
References: bsc#1077989

Commit 1351e69fc6db ("scsi: lpfc: Add push-to-adapter support to sli4")
fails compilation on some 32-bit systems as writeq() is not supported on
all architectures. Additionally, it was pointed out that as writeX()
does byteswapping if necessary for pci vs the cpu endianness, the code
was broken on BE PPC.

After discussions with Arnd Bergmann, we've resolved the issue
to the following:
  Instead of writeX(), use __raw_writeX() - which writes to io
    space while preserving byte order. To use this, the code
    was changed to use a different buffer that lpfc prepped
    via sli_pcimem_bcopy() that was set to the bytestream to
    be written.
  On platforms with __raw_writeq support, use the routine, otherwise
    use __raw_writel()

[mkp: checkpatch]

Fixes: 1351e69fc6db ("scsi: lpfc: Add push-to-adapter support to sli4")
Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
Signed-off-by: James Smart <james.smart@broadcom.com>
Reviewed-by: Arnd Bergmann <arnd@arndb.de>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/scsi/lpfc/lpfc_sli.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c
index 4ce3ca6f4b79..d20cf51ca15d 100644
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@ -140,9 +140,16 @@ lpfc_sli4_wq_put(struct lpfc_queue *q, union lpfc_wqe *wqe)
 	lpfc_sli_pcimem_bcopy(wqe, temp_wqe, q->entry_size);
 	if (q->dpp_enable && q->phba->cfg_enable_dpp) {
 		/* write to DPP aperture taking advatage of Combined Writes */
-		tmp = (uint8_t *)wqe;
+		tmp = (uint8_t *)temp_wqe;
+#ifdef __raw_writeq
 		for (i = 0; i < q->entry_size; i += sizeof(uint64_t))
-			writeq(*((uint64_t *)(tmp + i)), q->dpp_regaddr + i);
+			__raw_writeq(*((uint64_t *)(tmp + i)),
+					q->dpp_regaddr + i);
+#else
+		for (i = 0; i < q->entry_size; i += sizeof(uint32_t))
+			__raw_writel(*((uint32_t *)(tmp + i)),
+					q->dpp_regaddr + i);
+#endif
 	}
 	/* ensure WQE bcopy and DPP flushed before doorbell write */
 	wmb();
-- 
2.12.3

