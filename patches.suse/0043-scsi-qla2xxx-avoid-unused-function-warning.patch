From: Arnd Bergmann <arnd@arndb.de>
Date: Fri, 30 Jun 2017 18:10:40 +0200
Subject: scsi: qla2xxx: avoid unused-function warning
Patch-mainline: v4.13-rc1
Git-commit: bcda771b2f7e4f2a7577eef62ddeb61394e03b69
References: FATE#322910

When NVMe support is disabled, we get a couple of harmless warnings:

drivers/scsi/qla2xxx/qla_nvme.c:667:13: error: 'qla_nvme_unregister_remote_port' defined but not used [-Werror=unused-function]
drivers/scsi/qla2xxx/qla_nvme.c:634:13: error: 'qla_nvme_abort_all' defined but not used [-Werror=unused-function]
drivers/scsi/qla2xxx/qla_nvme.c:604:12: error: 'qla_nvme_wait_on_rport_del' defined but not used [-Werror=unused-function]

This replaces the preprocessor checks in the code with equivalent
compiler conditionals, which lets gcc drop the unused functions without
warning, and is nicer to read.

Fixes: e84067d74301 ("scsi: qla2xxx: Add FC-NVMe F/W initialization and transport registration")
Signed-off-by: Arnd Bergmann <arnd@arndb.de>
Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/scsi/qla2xxx/Kconfig    |  1 +
 drivers/scsi/qla2xxx/qla_nvme.c | 20 ++++++++++++--------
 2 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/drivers/scsi/qla2xxx/Kconfig b/drivers/scsi/qla2xxx/Kconfig
index de952935b5d2..036cc3f217b1 100644
--- a/drivers/scsi/qla2xxx/Kconfig
+++ b/drivers/scsi/qla2xxx/Kconfig
@@ -2,6 +2,7 @@ config SCSI_QLA_FC
 	tristate "QLogic QLA2XXX Fibre Channel Support"
 	depends on PCI && SCSI
 	depends on SCSI_FC_ATTRS
+	depends on NVME_FC || !NVME_FC
 	select FW_LOADER
 	select BTREE
 	---help---
diff --git a/drivers/scsi/qla2xxx/qla_nvme.c b/drivers/scsi/qla2xxx/qla_nvme.c
index 53e58e9daba8..ec15a49532a6 100644
--- a/drivers/scsi/qla2xxx/qla_nvme.c
+++ b/drivers/scsi/qla2xxx/qla_nvme.c
@@ -17,10 +17,12 @@ static void qla_nvme_unregister_remote_port(struct work_struct *);
 
 int qla_nvme_register_remote(scsi_qla_host_t *vha, fc_port_t *fcport)
 {
-#if (IS_ENABLED(CONFIG_NVME_FC))
 	struct nvme_rport *rport;
 	int ret;
 
+	if (!IS_ENABLED(CONFIG_NVME_FC))
+		return 0;
+
 	if (fcport->nvme_flag & NVME_FLAG_REGISTERED)
 		return 0;
 
@@ -78,7 +80,6 @@ int qla_nvme_register_remote(scsi_qla_host_t *vha, fc_port_t *fcport)
 	init_waitqueue_head(&fcport->nvme_waitQ);
 	rport->fcport = fcport;
 	list_add_tail(&rport->list, &vha->nvme_rport_list);
-#endif
 	return 0;
 }
 
@@ -666,11 +667,13 @@ static void qla_nvme_abort_all(fc_port_t *fcport)
 
 static void qla_nvme_unregister_remote_port(struct work_struct *work)
 {
-#if (IS_ENABLED(CONFIG_NVME_FC))
 	struct fc_port *fcport = container_of(work, struct fc_port,
 	    nvme_del_work);
 	struct nvme_rport *rport, *trport;
 
+	if (!IS_ENABLED(CONFIG_NVME_FC))
+		return;
+
 	list_for_each_entry_safe(rport, trport,
 	    &fcport->vha->nvme_rport_list, list) {
 		if (rport->fcport == fcport) {
@@ -680,16 +683,17 @@ static void qla_nvme_unregister_remote_port(struct work_struct *work)
 			    fcport->nvme_remote_port);
 		}
 	}
-#endif
 }
 
 void qla_nvme_delete(scsi_qla_host_t *vha)
 {
-#if (IS_ENABLED(CONFIG_NVME_FC))
 	struct nvme_rport *rport, *trport;
 	fc_port_t *fcport;
 	int nv_ret;
 
+	if (!IS_ENABLED(CONFIG_NVME_FC))
+		return;
+
 	list_for_each_entry_safe(rport, trport, &vha->nvme_rport_list, list) {
 		fcport = rport->fcport;
 
@@ -711,17 +715,18 @@ void qla_nvme_delete(scsi_qla_host_t *vha)
 			ql_log(ql_log_info, vha, 0x2115,
 			    "Unregister of localport failed\n");
 	}
-#endif
 }
 
 void qla_nvme_register_hba(scsi_qla_host_t *vha)
 {
-#if (IS_ENABLED(CONFIG_NVME_FC))
 	struct nvme_fc_port_template *tmpl;
 	struct qla_hw_data *ha;
 	struct nvme_fc_port_info pinfo;
 	int ret;
 
+	if (!IS_ENABLED(CONFIG_NVME_FC))
+		return;
+
 	ha = vha->hw;
 	tmpl = &qla_nvme_fc_transport;
 
@@ -752,5 +757,4 @@ void qla_nvme_register_hba(scsi_qla_host_t *vha)
 	atomic_set(&vha->nvme_ref_count, 1);
 	vha->nvme_local_port->private = vha;
 	init_waitqueue_head(&vha->nvme_waitQ);
-#endif
 }
-- 
2.12.3

