From: Ilya Dryomov <idryomov@gmail.com>
Date: Mon, 15 Oct 2018 16:11:37 +0200
Subject: libceph, rbd, ceph: move ceph_osdc_alloc_messages() calls
Git-commit: 26f887e0a3c43f67b550e2e5d8a76e86ca11d188
Patch-mainline: v4.20-rc1
References: bsc#1135897

The current requirement is that ceph_osdc_alloc_messages() should be
called after oid and oloc are known.  In preparation for preallocating
message data items, move ceph_osdc_alloc_messages() further down, so
that it is called when OSD op codes are known.

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Acked-by: Luis Henriques <lhenriques@suse.com>
---
 drivers/block/rbd.c   |   21 ++++++++++++++-------
 fs/ceph/file.c        |   10 +++++-----
 net/ceph/osd_client.c |   38 +++++++++++++++++++++-----------------
 3 files changed, 40 insertions(+), 29 deletions(-)

--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -1827,9 +1827,6 @@ __rbd_osd_req_create(struct rbd_device *
 			rbd_dev->header.object_prefix, obj_request->object_no))
 		goto err_req;
 
-	if (ceph_osdc_alloc_messages(req, GFP_NOIO))
-		goto err_req;
-
 	return req;
 
 err_req:
@@ -2360,6 +2357,8 @@ static int rbd_img_request_fill(struct r
 		obj_request->img_offset = img_offset;
 
 		rbd_img_obj_request_fill(obj_request, osd_req, op_type, 0);
+		if (ceph_osdc_alloc_messages(osd_req, GFP_NOIO))
+			goto out_unwind;
 
 		img_offset += length;
 		resid -= length;
@@ -2472,6 +2471,10 @@ rbd_img_obj_parent_read_full_callback(st
 	op_type = rbd_img_request_op_type(orig_request->img_request);
 	rbd_img_obj_request_fill(orig_request, osd_req, op_type, 1);
 
+	img_result = ceph_osdc_alloc_messages(osd_req, GFP_NOIO);
+	if (img_result)
+		goto out_err;
+
 	/* All set, send it off. */
 
 	rbd_obj_request_submit(orig_request);
@@ -2667,6 +2670,10 @@ static int rbd_img_obj_exists_submit(str
 	stat_request->obj_request = obj_request;
 	stat_request->callback = rbd_img_obj_exists_callback;
 
+	ret = ceph_osdc_alloc_messages(stat_request->osd_req, GFP_NOIO);
+	if (ret)
+		goto fail_stat_request;
+
 	rbd_obj_request_submit(stat_request);
 	return 0;
 
@@ -4057,10 +4064,6 @@ static int rbd_obj_read_sync(struct rbd_
 	ceph_oloc_copy(&req->r_base_oloc, oloc);
 	req->r_flags = CEPH_OSD_FLAG_READ;
 
-	ret = ceph_osdc_alloc_messages(req, GFP_KERNEL);
-	if (ret)
-		goto out_req;
-
 	pages = ceph_alloc_page_vector(num_pages, GFP_KERNEL);
 	if (IS_ERR(pages)) {
 		ret = PTR_ERR(pages);
@@ -4071,6 +4074,10 @@ static int rbd_obj_read_sync(struct rbd_
 	osd_req_op_extent_osd_data_pages(req, 0, pages, buf_len, 0, false,
 					 true);
 
+	ret = ceph_osdc_alloc_messages(req, GFP_KERNEL);
+	if (ret)
+		goto out_req;
+
 	ceph_osdc_start_request(osdc, req, false);
 	ret = ceph_osdc_wait_request(osdc, req);
 	if (ret >= 0)
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -877,6 +877,11 @@ static void ceph_aio_retry_work(struct w
 	ceph_oloc_copy(&req->r_base_oloc, &orig_req->r_base_oloc);
 	ceph_oid_copy(&req->r_base_oid, &orig_req->r_base_oid);
 
+	req->r_ops[0] = orig_req->r_ops[0];
+
+	req->r_mtime = aio_req->mtime;
+	req->r_data_offset = req->r_ops[0].extent.offset;
+
 	ret = ceph_osdc_alloc_messages(req, GFP_NOFS);
 	if (ret) {
 		ceph_osdc_put_request(req);
@@ -884,11 +889,6 @@ static void ceph_aio_retry_work(struct w
 		goto out;
 	}
 
-	req->r_ops[0] = orig_req->r_ops[0];
-
-	req->r_mtime = aio_req->mtime;
-	req->r_data_offset = req->r_ops[0].extent.offset;
-
 	ceph_osdc_put_request(orig_req);
 
 	req->r_callback = ceph_aio_complete_req;
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -4459,12 +4459,6 @@ alloc_linger_request(struct ceph_osd_lin
 
 	ceph_oid_copy(&req->r_base_oid, &lreq->t.base_oid);
 	ceph_oloc_copy(&req->r_base_oloc, &lreq->t.base_oloc);
-
-	if (ceph_osdc_alloc_messages(req, GFP_NOIO)) {
-		ceph_osdc_put_request(req);
-		return NULL;
-	}
-
 	return req;
 }
 
@@ -4482,6 +4476,12 @@ alloc_watch_request(struct ceph_osd_ling
 	 * filled in by linger_submit().
 	 */
 	osd_req_op_watch_init(req, 0, 0, watch_opcode);
+
+	if (ceph_osdc_alloc_messages(req, GFP_NOIO)) {
+		ceph_osdc_put_request(req);
+		return NULL;
+	}
+
 	return req;
 }
 
@@ -4632,12 +4632,12 @@ int ceph_osdc_notify_ack(struct ceph_osd
 	ceph_oloc_copy(&req->r_base_oloc, oloc);
 	req->r_flags = CEPH_OSD_FLAG_READ;
 
-	ret = ceph_osdc_alloc_messages(req, GFP_NOIO);
+	ret = osd_req_op_notify_ack_init(req, 0, notify_id, cookie, payload,
+					 payload_len);
 	if (ret)
 		goto out_put_req;
 
-	ret = osd_req_op_notify_ack_init(req, 0, notify_id, cookie, payload,
-					 payload_len);
+	ret = ceph_osdc_alloc_messages(req, GFP_NOIO);
 	if (ret)
 		goto out_put_req;
 
@@ -4742,6 +4742,10 @@ int ceph_osdc_notify(struct ceph_osd_cli
 						 response_data),
 				 pages, PAGE_SIZE, 0, false, true);
 
+	ret = ceph_osdc_alloc_messages(lreq->reg_req, GFP_NOIO);
+	if (ret)
+		goto out_put_lreq;
+
 	linger_submit(lreq);
 	ret = linger_reg_commit_wait(lreq);
 	if (!ret)
@@ -4868,10 +4872,6 @@ int ceph_osdc_list_watchers(struct ceph_
 	ceph_oloc_copy(&req->r_base_oloc, oloc);
 	req->r_flags = CEPH_OSD_FLAG_READ;
 
-	ret = ceph_osdc_alloc_messages(req, GFP_NOIO);
-	if (ret)
-		goto out_put_req;
-
 	pages = ceph_alloc_page_vector(1, GFP_NOIO);
 	if (IS_ERR(pages)) {
 		ret = PTR_ERR(pages);
@@ -4883,6 +4883,10 @@ int ceph_osdc_list_watchers(struct ceph_
 						 response_data),
 				 pages, PAGE_SIZE, 0, false, true);
 
+	ret = ceph_osdc_alloc_messages(req, GFP_NOIO);
+	if (ret)
+		goto out_put_req;
+
 	ceph_osdc_start_request(osdc, req, false);
 	ret = ceph_osdc_wait_request(osdc, req);
 	if (ret >= 0) {
@@ -4945,10 +4949,6 @@ int ceph_osdc_call(struct ceph_osd_clien
 	ceph_oloc_copy(&req->r_base_oloc, oloc);
 	req->r_flags = flags;
 
-	ret = ceph_osdc_alloc_messages(req, GFP_NOIO);
-	if (ret)
-		goto out_put_req;
-
 	ret = osd_req_op_cls_init(req, 0, CEPH_OSD_OP_CALL, class, method);
 	if (ret)
 		goto out_put_req;
@@ -4960,6 +4960,10 @@ int ceph_osdc_call(struct ceph_osd_clien
 		osd_req_op_cls_response_data_pages(req, 0, &resp_page,
 						   *resp_len, 0, false, false);
 
+	ret = ceph_osdc_alloc_messages(req, GFP_NOIO);
+	if (ret)
+		goto out_put_req;
+
 	ceph_osdc_start_request(osdc, req, false);
 	ret = ceph_osdc_wait_request(osdc, req);
 	if (ret >= 0) {
