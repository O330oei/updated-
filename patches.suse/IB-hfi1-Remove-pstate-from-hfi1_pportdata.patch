From: Jakub Byczkowski <jakub.byczkowski@intel.com>
Date: Sun, 13 Aug 2017 08:08:52 -0700
Subject: IB/hfi1: Remove pstate from hfi1_pportdata
Patch-mainline: v4.14-rc1
Git-commit: d392a673e718767049824f99c76bb483d893b881
References: bsc#1060463 FATE#323043

Do not track physical state separately from host_link_state.
Deduce physical state from host_link_state when required.
Change cache_physical_state to log_physical_state to make
sure host_link_state reflects hardwares physical state properly.

Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
Reviewed-by: Ira Weiny <ira.weiny@intel.com>
Signed-off-by: Jakub Byczkowski <jakub.byczkowski@intel.com>
Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
Signed-off-by: Doug Ledford <dledford@redhat.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/hw/hfi1/chip.c |   54 +++++++++++++++++++++-----------------
 drivers/infiniband/hw/hfi1/chip.h |    3 --
 drivers/infiniband/hw/hfi1/hfi.h  |   24 ----------------
 drivers/infiniband/hw/hfi1/mad.c  |    2 -
 4 files changed, 33 insertions(+), 50 deletions(-)

--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -1068,6 +1068,8 @@ static int thermal_init(struct hfi1_devd
 static void update_statusp(struct hfi1_pportdata *ppd, u32 state);
 static int wait_logical_linkstate(struct hfi1_pportdata *ppd, u32 state,
 				  int msecs);
+static void log_state_transition(struct hfi1_pportdata *ppd, u32 state);
+static void log_physical_state(struct hfi1_pportdata *ppd, u32 state);
 static int wait_physical_linkstate(struct hfi1_pportdata *ppd, u32 state,
 				   int msecs);
 static void read_planned_down_reason_code(struct hfi1_devdata *dd, u8 *pdrrc);
@@ -10450,11 +10452,11 @@ static const char *link_state_reason_nam
 }
 
 /*
- * driver_physical_state - convert the driver's notion of a port's
+ * driver_pstate - convert the driver's notion of a port's
  * state (an HLS_*) into a physical state (a {IB,OPA}_PORTPHYSSTATE_*).
  * Return -1 (converted to a u32) to indicate error.
  */
-u32 driver_physical_state(struct hfi1_pportdata *ppd)
+u32 driver_pstate(struct hfi1_pportdata *ppd)
 {
 	switch (ppd->host_link_state) {
 	case HLS_UP_INIT:
@@ -10720,7 +10722,7 @@ int set_link_state(struct hfi1_pportdata
 		if (ret)
 			goto_offline(ppd, 0);
 		else
-			cache_physical_state(ppd);
+			log_physical_state(ppd, PLS_POLLING);
 		break;
 	case HLS_DN_DISABLE:
 		/* link is disabled */
@@ -10769,7 +10771,7 @@ int set_link_state(struct hfi1_pportdata
 		if (ppd->host_link_state != HLS_DN_POLL)
 			goto unexpected;
 		ppd->host_link_state = HLS_VERIFY_CAP;
-		cache_physical_state(ppd);
+		log_physical_state(ppd, PLS_CONFIGPHY_VERIFYCAP);
 		break;
 	case HLS_GOING_UP:
 		if (ppd->host_link_state != HLS_VERIFY_CAP)
@@ -12743,25 +12745,30 @@ static int wait_logical_linkstate(struct
 	return 0;
 }
 
+static void log_state_transition(struct hfi1_pportdata *ppd, u32 state)
+{
+	u32 ib_pstate = chip_to_opa_pstate(ppd->dd, state);
+
+	dd_dev_info(ppd->dd,
+		    "physical state changed to %s (0x%x), phy 0x%x\n",
+		    opa_pstate_name(ib_pstate), ib_pstate, state);
+}
+
 /*
- * Read the physical hardware link state and set the driver's cached value
- * of it.
+ * Read the physical hardware link state and check if it matches host
+ * drivers anticipated state.
  */
-void cache_physical_state(struct hfi1_pportdata *ppd)
+static void log_physical_state(struct hfi1_pportdata *ppd, u32 state)
 {
-	u32 read_pstate;
-	u32 ib_pstate;
+	u32 read_state = read_physical_state(ppd->dd);
 
-	read_pstate = read_physical_state(ppd->dd);
-	ib_pstate = chip_to_opa_pstate(ppd->dd, read_pstate);
-	/* check if OPA pstate changed */
-	if (chip_to_opa_pstate(ppd->dd, ppd->pstate) != ib_pstate) {
-		dd_dev_info(ppd->dd,
-			    "%s: physical state changed to %s (0x%x), phy 0x%x\n",
-			    __func__, opa_pstate_name(ib_pstate), ib_pstate,
-			    read_pstate);
+	if (read_state == state) {
+		log_state_transition(ppd, state);
+	} else {
+		dd_dev_err(ppd->dd,
+			   "anticipated phy link state 0x%x, read 0x%x\n",
+			   state, read_state);
 	}
-	ppd->pstate = read_pstate;
 }
 
 /*
@@ -12776,22 +12783,24 @@ void cache_physical_state(struct hfi1_pp
 static int wait_physical_linkstate(struct hfi1_pportdata *ppd, u32 state,
 				   int msecs)
 {
+	u32 read_state;
 	unsigned long timeout;
 
 	timeout = jiffies + msecs_to_jiffies(msecs);
 	while (1) {
-		cache_physical_state(ppd);
-		if (ppd->pstate == state)
+		read_state = read_physical_state(ppd->dd);
+		if (read_state == state)
 			break;
 		if (time_after(jiffies, timeout)) {
 			dd_dev_err(ppd->dd,
-				   "timeout waiting for phy link state 0x%x, current state is 0x%x\n",
-				   state, ppd->pstate);
+				   "timeout waiting for phy link state 0x%x\n",
+				   state);
 			return -ETIMEDOUT;
 		}
 		usleep_range(1950, 2050); /* sleep 2ms-ish */
 	}
 
+	log_state_transition(ppd, state);
 	return 0;
 }
 
@@ -14896,7 +14905,6 @@ struct hfi1_devdata *hfi1_init_dd(struct
 		/* start in offline */
 		ppd->host_link_state = HLS_DN_OFFLINE;
 		init_vl_arb_caches(ppd);
-		ppd->pstate = PLS_OFFLINE;
 	}
 
 	dd->link_default = HLS_DN_POLL;
--- a/drivers/infiniband/hw/hfi1/chip.h
+++ b/drivers/infiniband/hw/hfi1/chip.h
@@ -747,10 +747,9 @@ int is_ax(struct hfi1_devdata *dd);
 int is_bx(struct hfi1_devdata *dd);
 u32 read_physical_state(struct hfi1_devdata *dd);
 u32 chip_to_opa_pstate(struct hfi1_devdata *dd, u32 chip_pstate);
-void cache_physical_state(struct hfi1_pportdata *ppd);
 const char *opa_lstate_name(u32 lstate);
 const char *opa_pstate_name(u32 pstate);
-u32 driver_physical_state(struct hfi1_pportdata *ppd);
+u32 driver_pstate(struct hfi1_pportdata *ppd);
 u32 driver_lstate(struct hfi1_pportdata *ppd);
 
 int acquire_lcb_access(struct hfi1_devdata *dd, int sleep_ok);
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -758,7 +758,6 @@ struct hfi1_pportdata {
 	u8 link_enabled;	/* link enabled? */
 	u8 linkinit_reason;
 	u8 local_tx_rate;	/* rate given to 8051 firmware */
-	u8 pstate;		/* info only */
 	u8 qsfp_retry_count;
 
 	/* placeholders for IB MAD packet settings */
@@ -1428,29 +1427,6 @@ static inline __le32 *get_rhf_addr(struc
 
 int hfi1_reset_device(int);
 
-/* return the driver's idea of the physical OPA port state */
-static inline u32 driver_pstate(struct hfi1_pportdata *ppd)
-{
-	/*
-	 * When DC is shut down and state is changed, its CSRs are not
-	 * impacted, therefore host_link_state should be used to get
-	 * current physical state.
-	 */
-	if (ppd->dd->dc_shutdown)
-		return driver_physical_state(ppd);
-	/*
-	 * The driver does some processing from the time the physical
-	 * link state is at LINKUP to the time the SM can be notified
-	 * as such. Return IB_PORTPHYSSTATE_TRAINING until the software
-	 * state is ready.
-	 */
-	if (ppd->pstate == PLS_LINKUP &&
-	    !(ppd->host_link_state & HLS_UP))
-		return IB_PORTPHYSSTATE_TRAINING;
-	else
-		return chip_to_opa_pstate(ppd->dd, ppd->pstate);
-}
-
 void receive_interrupt_work(struct work_struct *work);
 
 /* extract service channel from header and rhf */
--- a/drivers/infiniband/hw/hfi1/mad.c
+++ b/drivers/infiniband/hw/hfi1/mad.c
@@ -1181,7 +1181,7 @@ static int physical_transition_allowed(i
 static int port_states_transition_allowed(struct hfi1_pportdata *ppd,
 					  u32 logical_new, u32 physical_new)
 {
-	u32 physical_old = driver_physical_state(ppd);
+	u32 physical_old = driver_pstate(ppd);
 	u32 logical_old = driver_lstate(ppd);
 	int ret, logical_allowed, physical_allowed;
 
