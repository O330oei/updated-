From 69b957c26b32c3407d1b8cc0d2390b271728db8a Mon Sep 17 00:00:00 2001
From: Lv Zheng <lv.zheng@intel.com>
Date: Thu, 17 Aug 2017 10:21:12 +0800
Subject: [PATCH] ACPI: EC: Fix possible issues related to EC initialization order
Git-commit: 69b957c26b32c3407d1b8cc0d2390b271728db8a
Patch-mainline: v4.14-rc1
References: bsc#1051510

Use the observation that the EC command/data register addresses are
sufficient to determine if two EC devices are equivelent to modify
acpi_is_boot_ec().

Then, for the removed comparison factors, EC ID and EC GPE, they need
to be synchronized for the boot_ec:

 1. Before registering the BIOS-provided EC event handlers in
    acpi_ec_register_query_methods(), the namespace node holding
    _Qxx methods should be located.  The real namespace PNP0C09
    device location then is apparently more trustworthy than the
    ECDT EC ID.

 2. Because of the ASUS quirks, the ECDT EC GPE is more trustworthy
    than the namespace PNP0C09 device's _GPE setting.

Use the above observations to synchronize the boot_ec settings in
acpi_ec_add().

Finally, change the order of acpi_ec_ecdt_start() and acpi_ec_add(),
called from acpi_bus_register_driver(), so as to follow the fast path
of determining the location of _Qxx.

Signed-off-by: Lv Zheng <lv.zheng@intel.com>
[ rjw : Changelog & comments ]

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/acpi/ec.c |   25 ++++++++++++++++---------
 1 file changed, 16 insertions(+), 9 deletions(-)

--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -1564,9 +1564,7 @@ static bool acpi_is_boot_ec(struct acpi_
 {
 	if (!boot_ec)
 		return false;
-	if (ec->handle == boot_ec->handle &&
-	    ec->gpe == boot_ec->gpe &&
-	    ec->command_addr == boot_ec->command_addr &&
+	if (ec->command_addr == boot_ec->command_addr &&
 	    ec->data_addr == boot_ec->data_addr)
 		return true;
 	return false;
@@ -1591,6 +1589,13 @@ static int acpi_ec_add(struct acpi_devic
 
 	if (acpi_is_boot_ec(ec)) {
 		boot_ec_is_ecdt = false;
+		/*
+		 * Trust PNP0C09 namespace location rather than ECDT ID.
+		 *
+		 * But trust ECDT GPE rather than _GPE because of ASUS quirks,
+		 * so do not change boot_ec->gpe to ec->gpe.
+		 */
+		boot_ec->handle = ec->handle;
 		acpi_handle_debug(ec->handle, "duplicated.\n");
 		acpi_ec_free(ec);
 		ec = boot_ec;
@@ -1711,18 +1716,20 @@ static int __init acpi_ec_ecdt_start(voi
 
 	if (!boot_ec)
 		return -ENODEV;
-	/*
-	 * The DSDT EC should have already been started in
-	 * acpi_ec_add().
-	 */
+	/* In case acpi_ec_ecdt_start() is called after acpi_ec_add() */
 	if (!boot_ec_is_ecdt)
 		return -ENODEV;
 
 	/*
 	 * At this point, the namespace and the GPE is initialized, so
 	 * start to find the namespace objects and handle the events.
+	 *
+	 * Note: ec->handle can be valid if this function is called after
+	 * acpi_ec_add(), hence the fast path.
 	 */
-	if (!acpi_ec_ecdt_get_handle(&handle))
+	if (boot_ec->handle != ACPI_ROOT_OBJECT)
+		handle = boot_ec->handle;
+	else if (!acpi_ec_ecdt_get_handle(&handle))
 		return -ENODEV;
 	return acpi_config_boot_ec(boot_ec, handle, true, true);
 }
@@ -1916,8 +1923,8 @@ int __init acpi_ec_init(void)
 		return result;
 
 	/* Drivers must be started after acpi_ec_query_init() */
-	ecdt_fail = acpi_ec_ecdt_start();
 	dsdt_fail = acpi_bus_register_driver(&acpi_ec_driver);
+	ecdt_fail = acpi_ec_ecdt_start();
 	return ecdt_fail && dsdt_fail ? -ENODEV : 0;
 }
 
