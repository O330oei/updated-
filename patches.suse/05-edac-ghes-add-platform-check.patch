From: Toshi Kani <toshi.kani@hpe.com>
Date: Wed, 23 Aug 2017 16:54:45 -0600
Subject: EDAC, ghes: Add platform check
Git-commit: 5deed6b6a479ad5851d7ead6412dc6faa84a694e
Patch-mainline: v4.15-rc1
References: bsc#1042420

The ghes_edac driver was introduced in 2013 [1], but it has not been
enabled by any distro yet. This driver obtains error info from firmware
interfaces (APEI), which are not properly implemented on many platforms,
as the driver says on load:

  This EDAC driver relies on BIOS to enumerate memory and get error
  reports. Unfortunately, not all BIOSes reflect the memory layout
  correctly. So, the end result of using this driver varies from vendor
  to vendor. If you find incorrect reports, please contact your hardware
  vendor to correct its BIOS.

To get out from this situation, add a platform check to selectively
enable the driver on platforms that are known to have proper APEI
firmware implementation.

"ghes_edac.force_load=1" skips this platform check.

[1]: https://lkml.kernel.org/r/cover.1360931635.git.mchehab@redhat.com

Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
Cc: Tony Luck <tony.luck@intel.com>
Cc: linux-acpi@vger.kernel.org
Cc: linux-edac <linux-edac@vger.kernel.org>
Link: http://lkml.kernel.org/r/20170823225447.15608-4-toshi.kani@hpe.com
Signed-off-by: Borislav Petkov <bp@suse.de>
---
 drivers/edac/ghes_edac.c |   28 +++++++++++++++++++++++-----
 1 file changed, 23 insertions(+), 5 deletions(-)

--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -40,6 +40,10 @@ static struct ghes_edac_pvt *ghes_pvt;
  */
 static DEFINE_SPINLOCK(ghes_lock);
 
+/* "ghes_edac.force_load=1" skips the platform check */
+static bool __read_mostly force_load;
+module_param(force_load, bool, 0);
+
 /* Memory Device - Type 17 of SMBIOS spec */
 struct memdev_dmi_entry {
 	u8 type;
@@ -417,6 +421,14 @@ void ghes_edac_report_mem_error(struct g
 	spin_unlock_irqrestore(&ghes_lock, flags);
 }
 
+/*
+ * Known systems that are safe to enable this module.
+ */
+static struct acpi_platform_list plat_list[] = {
+	{"HPE   ", "Server  ", 0, ACPI_SIG_FADT, all_versions},
+	{ } /* End */
+};
+
 int ghes_edac_register(struct ghes *ghes, struct device *dev)
 {
 	bool fake = false;
@@ -424,6 +436,12 @@ int ghes_edac_register(struct ghes *ghes
 	struct mem_ctl_info *mci;
 	struct edac_mc_layer layers[1];
 	struct ghes_edac_dimm_fill dimm_fill;
+	int idx;
+
+	/* Check if safe to enable on this system */
+	idx = acpi_match_platform_list(plat_list);
+	if (!force_load && idx < 0)
+		return 0;
 
 	/*
 	 * We have only one logical memory controller to which all DIMMs belong.
@@ -463,17 +481,17 @@ int ghes_edac_register(struct ghes *ghes
 	mci->ctl_name = "ghes_edac";
 	mci->dev_name = "ghes";
 
-	if (!fake) {
+	if (fake) {
+		pr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");
+		pr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");
+		pr_info("work on such system. Use this driver with caution\n");
+	} else if (idx < 0) {
 		pr_info("This EDAC driver relies on BIOS to enumerate memory and get error reports.\n");
 		pr_info("Unfortunately, not all BIOSes reflect the memory layout correctly.\n");
 		pr_info("So, the end result of using this driver varies from vendor to vendor.\n");
 		pr_info("If you find incorrect reports, please contact your hardware vendor\n");
 		pr_info("to correct its BIOS.\n");
 		pr_info("This system has %d DIMM sockets.\n", num_dimm);
-	} else {
-		pr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");
-		pr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");
-		pr_info("work on such system. Use this driver with caution\n");
 	}
 
 	if (!fake) {
