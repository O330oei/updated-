From: Stephen Hemminger <stephen@networkplumber.org>
Date: Mon, 5 Feb 2018 10:40:27 -0800
Patch-mainline: v4.17-rc1
Subject: uio_hv_generic: support sub-channels
Git-commit: 37b96a4931dba07cebbf07092e55d1562155412b
References: bsc#1107207

Use sysfs to allow supporting sub-channels. The userspace application
makes request to host to create sub-channels and the UIO kernel
driver populates the sysfs per-channel directory with a binary
attribute file that can be used to read/write ring.

Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Olaf Hering <ohering@suse.de>
---
 Documentation/ABI/stable/sysfs-bus-vmbus |  7 +++
 Documentation/driver-api/uio-howto.rst   |  5 ++
 drivers/uio/uio_hv_generic.c             | 89 ++++++++++++++++++++++++++++++++
 3 files changed, 101 insertions(+)

diff --git a/drivers/uio/uio_hv_generic.c b/drivers/uio/uio_hv_generic.c
--- a/drivers/uio/uio_hv_generic.c
+++ b/drivers/uio/uio_hv_generic.c
@@ -121,6 +121,94 @@ static void hv_uio_rescind(struct vmbus_channel *channel)
 	uio_event_notify(&pdata->info);
 }
 
+/*
+ * Handle fault when looking for sub channel ring buffer
+ * Subchannel ring buffer is same as resource 0 which is main ring buffer
+ * This is derived from uio_vma_fault
+ */
+static int hv_uio_vma_fault(struct vm_fault *vmf)
+{
+	struct vm_area_struct *vma = vmf->vma;
+	void *ring_buffer = vma->vm_private_data;
+	struct page *page;
+	void *addr;
+
+	addr = ring_buffer + (vmf->pgoff << PAGE_SHIFT);
+	page = virt_to_page(addr);
+	get_page(page);
+	vmf->page = page;
+	return 0;
+}
+
+static const struct vm_operations_struct hv_uio_vm_ops = {
+	.fault = hv_uio_vma_fault,
+};
+
+/* Sysfs API to allow mmap of the ring buffers */
+static int hv_uio_ring_mmap(struct file *filp, struct kobject *kobj,
+			    struct bin_attribute *attr,
+			    struct vm_area_struct *vma)
+{
+	struct vmbus_channel *channel
+		= container_of(kobj, struct vmbus_channel, kobj);
+	unsigned long requested_pages, actual_pages;
+
+	if (vma->vm_end < vma->vm_start)
+		return -EINVAL;
+
+	/* only allow 0 for now */
+	if (vma->vm_pgoff > 0)
+		return -EINVAL;
+
+	requested_pages = vma_pages(vma);
+	actual_pages = 2 * HV_RING_SIZE;
+	if (requested_pages > actual_pages)
+		return -EINVAL;
+
+	vma->vm_private_data = channel->ringbuffer_pages;
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+	vma->vm_ops = &hv_uio_vm_ops;
+	return 0;
+}
+
+static struct bin_attribute ring_buffer_bin_attr __ro_after_init = {
+	.attr = {
+		.name = "ring",
+		.mode = 0600,
+		/* size is set at init time */
+	},
+	.mmap = hv_uio_ring_mmap,
+};
+
+/* Callback from VMBUS subystem when new channel created. */
+static void
+hv_uio_new_channel(struct vmbus_channel *new_sc)
+{
+	struct hv_device *hv_dev = new_sc->primary_channel->device_obj;
+	struct device *device = &hv_dev->device;
+	struct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);
+	const size_t ring_bytes = HV_RING_SIZE * PAGE_SIZE;
+	int ret;
+
+	/* Create host communication ring */
+	ret = vmbus_open(new_sc, ring_bytes, ring_bytes, NULL, 0,
+			 hv_uio_channel_cb, pdata);
+	if (ret) {
+		dev_err(device, "vmbus_open subchannel failed: %d\n", ret);
+		return;
+	}
+
+	/* Disable interrupts on sub channel */
+	new_sc->inbound.ring_buffer->interrupt_mask = 1;
+	set_channel_read_mode(new_sc, HV_CALL_ISR);
+
+	ret = sysfs_create_bin_file(&new_sc->kobj, &ring_buffer_bin_attr);
+	if (ret) {
+		dev_err(device, "sysfs create ring bin file failed; %d\n", ret);
+		vmbus_close(new_sc);
+	}
+}
+
 static void
 hv_uio_cleanup(struct hv_device *dev, struct hv_uio_private_data *pdata)
 {
@@ -236,6 +324,7 @@ hv_uio_probe(struct hv_device *dev,
 	}
 
 	vmbus_set_chn_rescind_callback(dev->channel, hv_uio_rescind);
+	vmbus_set_sc_create_callback(dev->channel, hv_uio_new_channel);
 
 	hv_set_drvdata(dev, pdata);
 
