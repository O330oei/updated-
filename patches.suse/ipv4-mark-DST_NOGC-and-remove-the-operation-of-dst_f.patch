From: Wei Wang <weiwan@google.com>
Date: Sat, 17 Jun 2017 10:42:32 -0700
Subject: ipv4: mark DST_NOGC and remove the operation of dst_free()
Patch-mainline: v4.13-rc1
Git-commit: b838d5e1c5b6e57b10ec8af2268824041e3ea911
References: bsc#1061739

With the previous preparation patches, we are ready to get rid of the
dst gc operation in ipv4 code and release dst based on refcnt only.
So this patch adds DST_NOGC flag for all IPv4 dst and remove the calls
to dst_free().
At this point, all dst created in ipv4 code do not use the dst gc
anymore and will be destroyed at the point when refcnt drops to 0.

Signed-off-by: Wei Wang <weiwan@google.com>
Acked-by: Martin KaFai Lau <kafai@fb.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Michal Kubecek <mkubecek@suse.cz>

---
 net/ipv4/fib_semantics.c |  6 ++----
 net/ipv4/route.c         | 15 +++------------
 2 files changed, 5 insertions(+), 16 deletions(-)

diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index b7c0bf6c9d06..12850ed4cd91 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -152,8 +152,7 @@ static void rt_fibinfo_free(struct rtable __rcu **rtp)
 	 */
 
 	dst_dev_put(&rt->dst);
-	dst_release(&rt->dst);
-	dst_free(&rt->dst);
+	dst_release_immediate(&rt->dst);
 }
 
 static void free_nh_exceptions(struct fib_nh *nh)
@@ -197,8 +196,7 @@ static void rt_fibinfo_free_cpus(struct rtable __rcu * __percpu *rtp)
 		rt = rcu_dereference_protected(*per_cpu_ptr(rtp, cpu), 1);
 		if (rt) {
 			dst_dev_put(&rt->dst);
-			dst_release(&rt->dst);
-			dst_free(&rt->dst);
+			dst_release_immediate(&rt->dst);
 		}
 	}
 	free_percpu(rtp);
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 932196f984e8..1f813ffe2b9a 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -587,11 +587,6 @@ static void ip_rt_build_flow_key(struct flowi4 *fl4, const struct sock *sk,
 		build_sk_flow_key(fl4, sk);
 }
 
-static inline void rt_free(struct rtable *rt)
-{
-	call_rcu(&rt->dst.rcu_head, dst_rcu_free);
-}
-
 static DEFINE_SPINLOCK(fnhe_lock);
 
 static void fnhe_flush_routes(struct fib_nh_exception *fnhe)
@@ -603,14 +598,12 @@ static void fnhe_flush_routes(struct fib_nh_exception *fnhe)
 		RCU_INIT_POINTER(fnhe->fnhe_rth_input, NULL);
 		dst_dev_put(&rt->dst);
 		dst_release(&rt->dst);
-		rt_free(rt);
 	}
 	rt = rcu_dereference(fnhe->fnhe_rth_output);
 	if (rt) {
 		RCU_INIT_POINTER(fnhe->fnhe_rth_output, NULL);
 		dst_dev_put(&rt->dst);
 		dst_release(&rt->dst);
-		rt_free(rt);
 	}
 }
 
@@ -1339,7 +1332,6 @@ static bool rt_bind_exception(struct rtable *rt, struct fib_nh_exception *fnhe,
 			if (orig) {
 				dst_dev_put(&orig->dst);
 				dst_release(&orig->dst);
-				rt_free(orig);
 			}
 			ret = true;
 		}
@@ -1372,7 +1364,6 @@ static bool rt_cache_route(struct fib_nh *nh, struct rtable *rt)
 		if (orig) {
 			dst_dev_put(&orig->dst);
 			dst_release(&orig->dst);
-			rt_free(orig);
 		}
 	} else {
 		dst_release(&rt->dst);
@@ -1503,7 +1494,8 @@ struct rtable *rt_dst_alloc(struct net_device *dev,
 	rt = dst_alloc(&ipv4_dst_ops, dev, 1, DST_OBSOLETE_FORCE_CHK,
 		       (will_cache ? 0 : (DST_HOST | DST_NOCACHE)) |
 		       (nopolicy ? DST_NOPOLICY : 0) |
-		       (noxfrm ? DST_NOXFRM : 0));
+		       (noxfrm ? DST_NOXFRM : 0) |
+		       DST_NOGC);
 
 	if (rt) {
 		rt->rt_genid = rt_genid_ipv4(dev_net(dev));
@@ -2492,7 +2484,7 @@ struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_or
 	struct rtable *ort = (struct rtable *) dst_orig;
 	struct rtable *rt;
 
-	rt = dst_alloc(&ipv4_dst_blackhole_ops, NULL, 1, DST_OBSOLETE_NONE, 0);
+	rt = dst_alloc(&ipv4_dst_blackhole_ops, NULL, 1, DST_OBSOLETE_NONE, DST_NOGC);
 	if (rt) {
 		struct dst_entry *new = &rt->dst;
 
@@ -2515,7 +2507,6 @@ struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_or
 		rt->rt_uses_gateway = ort->rt_uses_gateway;
 
 		INIT_LIST_HEAD(&rt->rt_uncached);
-		dst_free(new);
 	}
 
 	dst_release(dst_orig);
-- 
2.14.2

