From: Julian Wiedmann <jwi@linux.vnet.ibm.com>
Date: Tue, 15 Aug 2017 17:02:45 +0200
Subject: s390/qeth: make more use of skb API
Patch-mainline: v4.14-rc1
Git-commit: f8eb49306dfbdc3f929d09b584bdb834e940237c
References: bsc#1061024 FATE#323301

Replace some open-coded parts with their proper API calls.

Also remove two skb_[re]set_mac_header() calls in the L2
xmit paths that are clearly no longer required, since at least
commit 6d1ccff62780 ("net: reset mac header in dev_start_xmit()").

Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
Acked-by: Ursula Braun <ubraun@linux.vnet.ibm.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/s390/net/qeth_core.h      |    5 -----
 drivers/s390/net/qeth_core_main.c |   12 +++++-------
 drivers/s390/net/qeth_l2_main.c   |    7 +++----
 drivers/s390/net/qeth_l3_main.c   |    4 ++--
 4 files changed, 10 insertions(+), 18 deletions(-)

--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -857,11 +857,6 @@ static inline int qeth_get_ip_version(st
 	}
 }
 
-static inline int qeth_get_ip_protocol(struct sk_buff *skb)
-{
-	return ip_hdr(skb)->protocol;
-}
-
 static inline void qeth_put_buffer_pool_entry(struct qeth_card *card,
 		struct qeth_buffer_pool_entry *entry)
 {
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -3897,7 +3897,6 @@ static inline void __qeth_fill_buffer(st
 	int length = skb_headlen(skb) - offset;
 	char *data = skb->data + offset;
 	int length_here, cnt;
-	struct skb_frag_struct *frag;
 
 	/* map linear part into buffer element(s) */
 	while (length > 0) {
@@ -3927,10 +3926,10 @@ static inline void __qeth_fill_buffer(st
 
 	/* map page frags into buffer element(s) */
 	for (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {
-		frag = &skb_shinfo(skb)->frags[cnt];
-		data = (char *)page_to_phys(skb_frag_page(frag)) +
-			frag->page_offset;
-		length = frag->size;
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[cnt];
+
+		data = skb_frag_address(frag);
+		length = skb_frag_size(frag);
 		while (length > 0) {
 			length_here = PAGE_SIZE -
 				((unsigned long) data % PAGE_SIZE);
@@ -3976,8 +3975,7 @@ static inline int qeth_fill_buffer(struc
 		buffer->element[element].length = hdr_len;
 		buffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;
 		buf->next_element_to_fill++;
-		skb->data += hdr_len;
-		skb->len  -= hdr_len;
+		skb_pull(skb, hdr_len);
 	}
 
 	/* IQD */
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -752,11 +752,11 @@ static netdev_tx_t qeth_l2_hard_start_xm
 			if (!hdr)
 				goto tx_drop;
 			elements_needed++;
-			skb_reset_mac_header(new_skb);
 			qeth_l2_fill_header(card, hdr, new_skb, cast_type);
 			hdr->hdr.l2.pkt_length = new_skb->len;
-			memcpy(((char *)hdr) + sizeof(struct qeth_hdr),
-				skb_mac_header(new_skb), ETH_HLEN);
+			skb_copy_from_linear_data(new_skb,
+						  ((char *)hdr) + sizeof(*hdr),
+						  ETH_HLEN);
 		} else {
 			/* create a clone with writeable headroom */
 			new_skb = skb_realloc_headroom(skb,
@@ -764,7 +764,6 @@ static netdev_tx_t qeth_l2_hard_start_xm
 			if (!new_skb)
 				goto tx_drop;
 			hdr = skb_push(new_skb, sizeof(struct qeth_hdr));
-			skb_set_mac_header(new_skb, sizeof(struct qeth_hdr));
 			qeth_l2_fill_header(card, hdr, new_skb, cast_type);
 			if (new_skb->ip_summed == CHECKSUM_PARTIAL)
 				qeth_l2_hdr_csum(card, hdr, new_skb);
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -2570,7 +2570,7 @@ static void qeth_tso_fill_header(struct
 	hdr->ext.hdr_len     = 28;
 	/*insert non-fix values */
 	hdr->ext.mss = skb_shinfo(skb)->gso_size;
-	hdr->ext.dg_hdr_len = (__u16)(iph->ihl*4 + tcph->doff*4);
+	hdr->ext.dg_hdr_len = (__u16)(ip_hdrlen(skb) + tcp_hdrlen(skb));
 	hdr->ext.payload_len = (__u16)(skb->len - hdr->ext.dg_hdr_len -
 				       sizeof(struct qeth_hdr_tso));
 	tcph->check = 0;
@@ -2663,7 +2663,7 @@ static netdev_tx_t qeth_l3_hard_start_xm
 
 	/* Ignore segment size from skb_is_gso(), 1 page is always used. */
 	use_tso = skb_is_gso(skb) &&
-		  (qeth_get_ip_protocol(skb) == IPPROTO_TCP) && (ipv == 4);
+		  (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4);
 
 	if (card->info.type == QETH_CARD_TYPE_IQD) {
 		new_skb = skb;
