From: Torsten Duwe <duwe@suse.de>
Subject: Limit kABI breakage due to DH key verification
Patch-mainline: Never, kABI fix
References: bsc#1155331

https://jira.suse.com/browse/ECO-936

No need to change the ABI for non-FIPS-aware callers.
Put the new members to the end of the struct so that the offsets
don't change, and activate the new functionality only iff FIPS
mode is requested.

Cc: Petr Tesarik <ptesarik@suse.cz>
Cc: Takashi Iwai <tiwai@suse.de>

--- a/include/crypto/dh.h
+++ b/include/crypto/dh.h
@@ -39,12 +39,14 @@
 struct dh {
 	void *key;
 	void *p;
-	void *q;
 	void *g;
 	unsigned int key_size;
 	unsigned int p_size;
-	unsigned int q_size;
 	unsigned int g_size;
+#ifndef __GENKSYMS__
+	unsigned int q_size;
+	void *q;
+#endif
 };
 
 /**
--- a/crypto/dh_helper.c
+++ b/crypto/dh_helper.c
@@ -9,6 +9,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/export.h>
+#include <linux/fips.h>
 #include <linux/err.h>
 #include <linux/string.h>
 #include <crypto/dh.h>
@@ -30,7 +31,8 @@ static inline const u8 *dh_unpack_data(v
 
 static inline int dh_data_size(const struct dh *p)
 {
-	return p->key_size + p->p_size + p->q_size + p->g_size;
+	return p->key_size + p->p_size + (fips_enabled ? p->q_size : 0) +
+		p->g_size;
 }
 
 int crypto_dh_key_len(const struct dh *p)
@@ -56,11 +58,13 @@ int crypto_dh_encode_key(char *buf, unsi
 	ptr = dh_pack_data(ptr, &secret, sizeof(secret));
 	ptr = dh_pack_data(ptr, &params->key_size, sizeof(params->key_size));
 	ptr = dh_pack_data(ptr, &params->p_size, sizeof(params->p_size));
-	ptr = dh_pack_data(ptr, &params->q_size, sizeof(params->q_size));
+	if (fips_enabled)
+		ptr = dh_pack_data(ptr, &params->q_size, sizeof(params->q_size));
 	ptr = dh_pack_data(ptr, &params->g_size, sizeof(params->g_size));
 	ptr = dh_pack_data(ptr, params->key, params->key_size);
 	ptr = dh_pack_data(ptr, params->p, params->p_size);
-	ptr = dh_pack_data(ptr, params->q, params->q_size);
+	if (fips_enabled)
+		ptr = dh_pack_data(ptr, params->q, params->q_size);
 	dh_pack_data(ptr, params->g, params->g_size);
 
 	return 0;
@@ -81,7 +85,8 @@ int crypto_dh_decode_key(const char *buf
 
 	ptr = dh_unpack_data(&params->key_size, ptr, sizeof(params->key_size));
 	ptr = dh_unpack_data(&params->p_size, ptr, sizeof(params->p_size));
-	ptr = dh_unpack_data(&params->q_size, ptr, sizeof(params->q_size));
+	if (fips_enabled)
+		ptr = dh_unpack_data(&params->q_size, ptr, sizeof(params->q_size));
 	ptr = dh_unpack_data(&params->g_size, ptr, sizeof(params->g_size));
 	if (secret.len != crypto_dh_key_len(params))
 		return -EINVAL;
@@ -91,7 +96,8 @@ int crypto_dh_decode_key(const char *buf
 	 * some drivers assume otherwise.
 	 */
 	if (params->key_size > params->p_size ||
-	    params->g_size > params->p_size || params->q_size > params->p_size)
+	    params->g_size > params->p_size ||
+	    (fips_enabled && (params->q_size > params->p_size)) )
 		return -EINVAL;
 
 	/* Don't allocate memory. Set pointers to data within
@@ -101,7 +107,7 @@ int crypto_dh_decode_key(const char *buf
 	params->p = (void *)(ptr + params->key_size);
 	params->q = (void *)(ptr + params->key_size + params->p_size);
 	params->g = (void *)(ptr + params->key_size + params->p_size +
-			     params->q_size);
+			     (fips_enabled ? params->q_size : 0) );
 
 	/*
 	 * Don't permit 'p' to be 0.  It's not a prime number, and it's subject
@@ -112,7 +118,7 @@ int crypto_dh_decode_key(const char *buf
 		return -EINVAL;
 
 	/* It is permissible to not provide Q. */
-	if (params->q_size == 0)
+	if (fips_enabled && params->q_size == 0)
 		params->q = NULL;
 
 	return 0;
--- a/crypto/dh.c
+++ b/crypto/dh.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/fips.h>
 #include <crypto/internal/kpp.h>
 #include <crypto/kpp.h>
 #include <crypto/dh.h>
@@ -65,7 +66,7 @@ static int dh_set_params(struct dh_ctx *
 	if (!ctx->p)
 		return -EINVAL;
 
-	if (params->q && params->q_size) {
+	if (fips_enabled && params->q && params->q_size) {
 		ctx->q = mpi_read_raw_data(params->q, params->q_size);
 		if (!ctx->q)
 			return -EINVAL;
@@ -175,9 +176,11 @@ static int dh_compute_value(struct kpp_r
 			ret = -EINVAL;
 			goto err_free_val;
 		}
-		ret = dh_is_pubkey_valid(ctx, base);
-		if (ret)
-			goto err_free_base;
+		if (fips_enabled) {
+			ret = dh_is_pubkey_valid(ctx, base);
+			if (ret)
+				goto err_free_base;
+		}
 	} else {
 		base = ctx->g;
 	}
