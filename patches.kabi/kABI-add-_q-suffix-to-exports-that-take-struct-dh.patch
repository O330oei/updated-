From f67b2860c00d242223c83ebb9cf78a409d94173a Mon Sep 17 00:00:00 2001
From: Michal Suchanek <msuchanek@suse.de>
Date: Mon, 16 Dec 2019 19:05:35 +0100
Subject: [PATCH] kABI: add _q suffix to exports that take struct dh

References: bsc#1155331
Patch-mainline: never, kABI

Also provide the old API with exports without suffix.

Signed-off-by: Michal Suchanek <msuchanek@suse.de>
---
 crypto/dh_helper.c  | 105 ++++++++++++++++++++++++++++++++++++++------
 include/crypto/dh.h |  25 +++++++++++
 3 files changed, 123 insertions(+), 16 deletions(-)

diff --git a/crypto/dh_helper.c b/crypto/dh_helper.c
index 8625cb0c2af9..50d3d0c8734f 100644
--- a/crypto/dh_helper.c
+++ b/crypto/dh_helper.c
@@ -14,6 +14,32 @@
 #include <crypto/dh.h>
 #include <crypto/kpp.h>
 
+#undef dh
+#undef crypto_dh_key_len
+#define DH_KPP_SECRET_MIN_SIZE_NO_Q (sizeof(struct kpp_secret) + 3 * sizeof(int))
+
+static inline int dh_data_size(const struct dh *p)
+{
+	return p->key_size + p->p_size + p->g_size;
+}
+
+int crypto_dh_key_len(const struct dh *p)
+{
+	return DH_KPP_SECRET_MIN_SIZE_NO_Q + dh_data_size(p);
+}
+EXPORT_SYMBOL_GPL(crypto_dh_key_len);
+
+/* Old calculation with new structure */
+static inline int dh_data_size_no_q(const struct dh_q *p)
+{
+	return p->key_size + p->p_size + p->g_size;
+}
+
+int crypto_dh_key_len_no_q(const struct dh_q *p)
+{
+	return DH_KPP_SECRET_MIN_SIZE_NO_Q + dh_data_size_no_q(p);
+}
+
 #define DH_KPP_SECRET_MIN_SIZE (sizeof(struct kpp_secret) + 4 * sizeof(int))
 
 static inline u8 *dh_pack_data(void *dst, const void *src, size_t size)
@@ -28,20 +54,21 @@ static inline const u8 *dh_unpack_data(void *dst, const void *src, size_t size)
 	return src + size;
 }
 
-static inline int dh_data_size(const struct dh *p)
+static inline int dh_data_size_q(const struct dh_q *p)
 {
 	return p->key_size + p->p_size + p->q_size + p->g_size;
 }
 
-int crypto_dh_key_len(const struct dh *p)
+int crypto_dh_key_len_q(const struct dh_q *p)
 {
-	return DH_KPP_SECRET_MIN_SIZE + dh_data_size(p);
+	return DH_KPP_SECRET_MIN_SIZE + dh_data_size_q(p);
 }
-EXPORT_SYMBOL_GPL(crypto_dh_key_len);
+EXPORT_SYMBOL_GPL(crypto_dh_key_len_q);
 
-int crypto_dh_encode_key(char *buf, unsigned int len, const struct dh *params)
+int crypto_dh_encode_key(char *buf, unsigned int len, const struct dh_q *params)
 {
 	u8 *ptr = buf;
+	bool do_q = true;
 	struct kpp_secret secret = {
 		.type = CRYPTO_KPP_SECRET_TYPE_DH,
 		.len = len
@@ -50,29 +77,33 @@ int crypto_dh_encode_key(char *buf, unsigned int len, const struct dh *params)
 	if (unlikely(!buf))
 		return -EINVAL;
 
-	if (len != crypto_dh_key_len(params))
+	if (len == crypto_dh_key_len_no_q(params) && !params->q_size)
+		do_q = false;
+	else if (len != crypto_dh_key_len_q(params))
 		return -EINVAL;
 
 	ptr = dh_pack_data(ptr, &secret, sizeof(secret));
 	ptr = dh_pack_data(ptr, &params->key_size, sizeof(params->key_size));
 	ptr = dh_pack_data(ptr, &params->p_size, sizeof(params->p_size));
-	ptr = dh_pack_data(ptr, &params->q_size, sizeof(params->q_size));
+	if (do_q)
+		ptr = dh_pack_data(ptr, &params->q_size, sizeof(params->q_size));
 	ptr = dh_pack_data(ptr, &params->g_size, sizeof(params->g_size));
 	ptr = dh_pack_data(ptr, params->key, params->key_size);
 	ptr = dh_pack_data(ptr, params->p, params->p_size);
-	ptr = dh_pack_data(ptr, params->q, params->q_size);
+	if (do_q)
+		ptr = dh_pack_data(ptr, params->q, params->q_size);
 	dh_pack_data(ptr, params->g, params->g_size);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(crypto_dh_encode_key);
 
-int crypto_dh_decode_key(const char *buf, unsigned int len, struct dh *params)
+int crypto_dh_decode_key(const char *buf, unsigned int len, struct dh_q *params)
 {
 	const u8 *ptr = buf;
 	struct kpp_secret secret;
 
-	if (unlikely(!buf || len < DH_KPP_SECRET_MIN_SIZE))
+	if (unlikely(!buf || len < DH_KPP_SECRET_MIN_SIZE_NO_Q))
 		return -EINVAL;
 
 	ptr = dh_unpack_data(&secret, ptr, sizeof(secret));
@@ -81,10 +112,21 @@ int crypto_dh_decode_key(const char *buf, unsigned int len, struct dh *params)
 
 	ptr = dh_unpack_data(&params->key_size, ptr, sizeof(params->key_size));
 	ptr = dh_unpack_data(&params->p_size, ptr, sizeof(params->p_size));
-	ptr = dh_unpack_data(&params->q_size, ptr, sizeof(params->q_size));
 	ptr = dh_unpack_data(&params->g_size, ptr, sizeof(params->g_size));
-	if (secret.len != crypto_dh_key_len(params))
-		return -EINVAL;
+	params->q_size = 0;
+	/*
+	 * G is not optional so if we assigned q_size to g_size here when
+	 * decoding a new key with Q parameter the length will not match on
+	 * well-formed key.
+	 */
+	if (secret.len != crypto_dh_key_len_no_q(params)) {
+		if (len < DH_KPP_SECRET_MIN_SIZE)
+			return -EINVAL;
+		params->q_size = params->g_size;
+		ptr = dh_unpack_data(&params->g_size, ptr, sizeof(params->g_size));
+		if (secret.len != crypto_dh_key_len_q(params))
+			return -EINVAL;
+	}
 
 	/*
 	 * Don't permit the buffer for 'key' or 'g' to be larger than 'p', since
@@ -118,3 +160,40 @@ int crypto_dh_decode_key(const char *buf, unsigned int len, struct dh *params)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(crypto_dh_decode_key);
+
+#undef crypto_dh_encode_key
+#undef crypto_dh_decode_key
+
+int crypto_dh_encode_key(char *buf, unsigned int len, const struct dh *old_params)
+{
+	struct dh_q params = {
+		.q_size = 0, .q = NULL,
+		.key_size = old_params->key_size,
+		.p_size = old_params->p_size,
+		.g_size = old_params->g_size,
+		.key = old_params->key,
+		.p = old_params->p,
+		.g = old_params->g,
+	};
+	return crypto_dh_encode_key_q(buf, len, &params);
+
+}
+EXPORT_SYMBOL_GPL(crypto_dh_encode_key);
+
+int crypto_dh_decode_key(const char *buf, unsigned int len, struct dh *old_params)
+{
+	struct dh_q params;
+	int ret = crypto_dh_decode_key_q(buf, len, &params);
+	if (ret)
+		return ret;
+	if (params.q_size)
+		return -EOPNOTSUPP;
+	old_params->key_size = params.key_size;
+	old_params->p_size = params.p_size;
+	old_params->g_size = params.g_size;
+	old_params->key = params.key;
+	old_params->p = params.p;
+	old_params->g = params.g;
+	return ret;
+}
+EXPORT_SYMBOL_GPL(crypto_dh_decode_key);
diff --git a/include/crypto/dh.h b/include/crypto/dh.h
index 6952b63f2957..b6b269878b57 100644
--- a/include/crypto/dh.h
+++ b/include/crypto/dh.h
@@ -13,6 +13,31 @@
 #ifndef _CRYPTO_DH_
 #define _CRYPTO_DH_
 
+/**
+ * struct dh - define a DH private key for old API without Q parameter
+ *
+ * @key:	Private DH key
+ * @p:		Diffie-Hellman parameter P
+ * @g:		Diffie-Hellman generator G
+ * @key_size:	Size of the private DH key
+ * @p_size:	Size of DH parameter P
+ * @g_size:	Size of DH generator G
+ */
+struct dh {
+	void *key;
+	void *p;
+	void *g;
+	unsigned int key_size;
+	unsigned int p_size;
+	unsigned int g_size;
+};
+
+/* kABI we added the q parameter to struct dh so interface of these functions changed. */
+#define dh dh_q
+#define crypto_dh_key_len crypto_dh_key_len_q
+#define crypto_dh_encode_key crypto_dh_encode_key_q
+#define crypto_dh_decode_key crypto_dh_decode_key_q
+
 /**
  * DOC: DH Helper Functions
  *
-- 
2.23.0

